Class Sugerencia
{
  Prenda parteSuperior;
  Prenda parteInferior;
  Prenda calzado;
  Prenda accesorio;
  List<Prenda> prendasExtras;
  ServicioMeteorologico servicioMeteorologico; 
  
  Sugerencia(Prenda parteSuperior, Prenda parteInferior, Prenda calzado, Prenda accesorio, ServicioMeteorologico  servicioMeteorologico){
   this.parteSuperior = parteSuperior;
   this.parteInferior = parteInferior;
   this.calzado = calzado;
   this.accesorio = accesorio;
   this.servicioMeteorologico = servicioMeteorologico
   }
   
   Atuendo crearAtuendo(){
   Atuendo atuendo = new Atuendo(parteSuperior, parteInferior, calzado, accesorio);
   prendasExtras.forEach({unaPrenda -> atuendo.agregarMasPrendas(unaPrenda)});
   temperaturaBuenosAires = servicioMeteorologico.obtenerCondicionesClimaticas("Buenos Aires);
    
   validarTemperaturaPrenda(temperaturaBuenosAires, parteSuperior);
   validarTemperaturaPrenda(temperaturaBuenosAires, parteInferior);
   validarTemperaturaPrenda(temperaturaBuenosAires, calzado);
   validarTemperaturaPrenda(temperaturaBuenosAires, accesorio);
   
   prendasExtras.forEach({unaPrenda -> validarTemperaturaPrendar(temperatura,unaPrenda)});
   
   return atuendo;
   
   }
   
  Void validarTemperaturaPrenda(temperatura, Prenda unaPrenda){
   if(unaPrenda.getTemperaturaMaxima() > temperatura){
     throw new TemperaturaMaximaException("La prenda sobrepasa la temperatura recomendada");
  }
}

Class Atuendo
{
  Prenda parteSuperior;
  Prenda parteInferior;
  Prenda calzado;
  Prenda accesorio;
  List<Prenda> prendasExtras;
  
  Atuendo(Prenda parteSuperior, Prenda parteInferior, Prenda calzado, Prenda accesorio){
   validarCategoriaPrenda(parteSuperior,PARTE_SUPERIOR);
   validarCategoriaPrenda(parteInferior,PARTE_INFERIOR);
   validarCategoriaPrenda(calzado,CALZADO);
   validarCategoriaPrenda(accesorio,ACCESORIO);
   this.parteSuperior = parteSuperior;
   this.parteInferior = parteInferior;
   this.calzado = calzado;
   this.accesorio = accesorio;
  }
   
  Void validarCategoriaPrenda(Prenda prenda, Categoria categoria){
   if(prenda.getCategoria != categoria){
     throw new CategoriaErroneaException("La prenda no se corresponde con la categoria a asignar");
     }
  }
    
  Void agregarMasPrendas(Prenda unaPrenda){
   prendasExtras.add(unaPrenda);
  }
}

  
Class Prenda
{ 
  Tipo tipo; 
  Categoria categoria;
  Material material;
  Color colorPrincipal;
  Color colorSecundario;
  Var temperaturaMaxima;
  
   Prenda(Tipo unTipo,Material unMaterial, Color unColorPrincipal,Categoria unaCategoria){ 
    if(unTipo == NULL){
      throw new TipoNuloException("La prenda debe tener un tipo");
      }
    if(unaCategoria == NULL){
       throw new CategoriaNulaException("La prenda debe tener una categoria");
      }
    if(unMaterial == NULL){
        throw new MaterialNuloException("La prenda debe tener un material");
      }
    if(unColor == NULL){
        throw new ColorNuloException("La prenda debe poseer un color principal");
      }

     if(unTipo.getCategoria != unaCategoria){  
     throw new CategoriaException("La categoria no se corresponde con el tipo");
    }
   
    this.tipo = unTipo;
    this.categoria = unaCategoria;
    this.material = unMaterial;
    this.colorPrincipal = unColorPrincipal;
   
    }
   
   Void elegirColorSecundario(Color unColor){
     this.colorSecundario = unColor;
   }
   
   Var getTemparutaMaxima(){
    return this.temperaturaMaxima;
    }
   
}
 
 
Class Tipo
{
   String nombre;
   Categoria categoria;
   
   Tipo(String nombre, Categoria categoria){
    this.nombre = nombre;
    this.categoria = categoria;
    }
    
   Categoria getCategoria(){
     return this.categoria;
    }  
 }
 
 
Enum Categoria
{
   PARTE_SUPERIOR,CALZADO,PARTE_INFERIOR,ACCESORIOS;
}
 
 
Class Color
{
    String codigoRGB;
    
    Color(String codigo){
      this.codigoRGB = codigo;
    }
}
 
 
Class Material
{
    TipoMaterial material;
    Trama trama = LISA;
    
    Material(TipoMaterial material){
     this.material = material;
    }
     
    Material(TipoMaterial material,Trama trama){
     this.material = material;
     this.trama = trama;
    }
}
 
 
Enum TipoMaterial
{
  LANA,ALGODON,SEDA,LINO,POLIESTER,PIEL,PIQUE; 
}
 
 
Enum Trama
{
  LISA,RAYADA,LUNARES,CUADROS,ESTAMPADO;
}
 
 
Class Borrador
{
   Tipo tipo 
   Categoria categoria
   Material material
   Color colorPrincipal
   Color colorSecundario
    
   Borrador(Tipo tipo){
    this.tipo = tipo;
   }
  
   Void setTipo(Tipo tipo){
    this.tipo = tipo;
   }
  
   Void setCategoria(Categoria unaCategoria){
    this.categoria = categoria;
   }
  
   Void setMaterial(Material material){
    this.material = material;
   }
  
   Void setColorPrincipal(Color color){
    this.colorPrincipal = color;
   }
  
   Void setColorSecundario(Color color){
    this.colorSecundario = color;
   }
    
   Prenda instanciarPrenda(){
    Prenda prenda = new Prenda(tipo,material,colorPrincipal,categoria);
    prenda.elegirColorSecundario(colorSecundario);
    return prenda;
   }
  
}
 
 
Class Usuario
{
    List<Uniforme> uniformesRecomendados;
    List<Atuendo> atuendosRecomendados;
    List<Guardaropa> misGuardarropas;
     
    void compartirGuardarropa(Guardarropa unGuardarropa){
      misGuardarropas.add(unGuardarropa);
    }
    
    //CÃ³digo duplicado pero que atacan distintos problemas, en lo que es modelar requerimientos lo veo bien separarlo.
    
    void agregarGuardarropa(Guardarropa unGuardarropa){
      this.misGuardaropas.add(guardaRopa);
    }
    
    void recibirPropuestaModificacion(Modificacion unaModificacion){
      unaModificacion.getguardarropa.agregarModificacion(unaModificacion);
    }
    
    void aceptarModificacion(Modificacion unaModificacion){
     unaModificacion.aplicarModificacion();
    }
    
    void rechazarModificacion(Modificacion unaModificacion){
       unaModificacion.getguardaRopa.quitarModificacion(unaModificacion);
     }
    }
    
    void deshacerUnaModificacion(Modificacion unaModificacion){
    unaModificacion.deshacerModificacion();
    }

    void recibirRecomendacionDeUniforme(Uniforme unUniforme){
      uniformesRecomendados.add(unUniforme);
      }
      
    void recibirRecomendacionDeAtuendo(Atuendo atuendo){
      atuendosRecomendados.add(atuendo);
      }
 }
 
Class Guardarropa
{
    List<Prenda> misPrendas;
    List<Modificacion> modificaciones;
    
    Guardarropa(Arraylist<Prenda> prendas){
    this.misPrendas = prendas;
    }
    
    void agregarUnaPrenda(Prenda prenda){
    misPrendas.add(prenda);
    }
    
    void quitarUnaPrenda(Prenda prenda){
    misPrendas.remove(prenda);
    }
    
    void agregarModificacion(Modificacion unaModificacion){
    modificaciones.add(unaModificacion);
    }
    
    void quitarModificacion(Modifcacion unaModificacion){
    modificaciones.remove(unaModificacion);
    }
   
}
 
Abstract Class Modificacion
{
  
  Prenda prenda;
  Guardaropa miGuardarropa;
  Estado estado;
 
  abstract method aplicarModificacion(){
    if(estado == APLICADA){
     throw new ModificacionException("La modficacion ya habia sido aplicada");
    }
    estado = APLICADA;
    this.aplicarOperacion();
  }
  
  abstract method deshacerModificacion(){
    if(estado == DESHECHA){
    throw new ModificacionException("No se puede deshacer una modificacion que no esta vigente");
    }
    estado = DESHECHA;
    this.deshacerOperacion();
  }
  
}
 
Class AgregarPrenda Extends Modificacion
{
   
   void aplicarOperacion(){
   miGuardaropa.agregarPrenda(prenda);
   }
   
   void deshacerOperacion(){
   miGuardaropa.quitarPrenda(prenda);
   }
    
}
 
Class QuitarPrenda Extends Modificacion
{
 
  void aplicarOperacion(){
   miGuardaropa.quitarPrenda(prenda);
   }
   
   void deshacerOperacion(){
   miGuardaropa.agregarPrenda(prenda);
   }
    
    
}

Enum Estado
{
 APLICADA,DESHECHA;
}
 
 
Interface ServicioMeteorologico
{
   EstadoDelTiempo obtenerCondicionesClimaticas(String direccion);
}
  
  
Class ServicioMeteorologicoAccuWeather implements ServicioMeteorologico
{

private Map<String, RespuestaMeteorologica> ultimasRespuestas;
public ServicioMeteorologico(AccuWeatherAPI api, Duration periodoDeValidez) { 
   this.api = api;            
   this.periodoDeValidez = periodoDeValidez;  
   this.ultimasRespuestas = new HashMap<String, Object>();
 }
  
 public EstadoDelTiempo obtenerCondicionesClimaticas(String direccion) {
   if (!this.ultimasRespuestas.contains(direccion) || this.ultimasRespuestas.get(direccion).expiro()) {
    ultimasRespuestas.put(new RespuestaMeteorologica(consultarApi(direccion), proximaExpiracion()));    
   }
   return this.ultimasRespuestas.get(direccion).getEstadoDelTiempo();
}  
 
 
CLass Uniforme
{
    Prenda prendaSuperior;
    Prenda prendaInferior;
    Prenda calzado
  
    Uniforme(Prenda prendaSuperior, Prenda prendaInferior, Prenda calzado){
      this.prendaSuperior = prendaSuperior;
      this.prendaInferior = prendaInferior;
      this.calzado = calzado;
    }
 }
  
  
 Class creadorDeUniformes
 {
   Uniforme armarUniforme(){
     return new Uniforme(this.crearParteSuperior(), this.crearParteInferior(), this.crearCalzado());
   }

   abstract Prenda crearParteSuperior();
   abstract Prenda crearParteInferior();
   abstract Prenda crearCalzado();
 }


//Estos uniformes no pasan por el control de Prenda, deben especificar todos los apartados del constructor...
 
Class UniformeSanJuan inherits creadorDeUniformes
{
 
  Super Prenda crearParteSuperior(){
    borrador = new Borrador(new Tipo("CHOMBA",PARTE_SUPERIOR));
    borrador.setColorPrincipal(new Color("008F39"));
    borrador.setMaterial(new Material("PIQUE"));
    borrador.setCategoria(PARTE_SUPERIOR);
    return borrador.instanciarPrenda();
  }

  Super Prenda crearParteInferior(){
    borrador = new Borrador(new Tipo("PANTALON",PARTE_INFERIOR));
    borrador.setColorPrincipal(new Color("9B9B9B"));
    borrador.setMaterial(new Material(ACETATO));
    borrador.setCategoria(PARTE_INFERIOR);
    return borrador.instanciarPrenda();
  }

  Super Prenda crearCalzado(){  
    borrador = new Borrador(new Tipo("ZAPATILLAS",CALZADO));
    borrador.setColorPrincipal(new Color("FFFFFF"));
    borrador.setCategoria(CALZADO);
    return borrador.instanciarPrenda();
  }
}
  
Class UniformeJohnson inherits creadorDeUniformes
{
 
  super Prenda crearParteSuperior(){
    borrador = new Borrador(new Tipo("CAMISA",PARTE_SUPERIOR));
    borrador.setColorPrincipal(new Color("FFFFFF));
    borrador.setCategoria(PARTE_SUPERIOR);
    return borrador.instanciarPrenda();
  }

  super Prenda crearParteInferior(){
    borrador = new Borrador(new Tipo("Pantalon de vestir",PARTE_INFERIOR));
    borrador.setColorPrincipal(new Color("0A0A0A"));
    borrador.setCategoria(PARTE_INFERIOR);
    return borrador.instanciarPrenda();
  }

  super Prenda crearCalzado(){
    borrador = new Borrador(new Tipo("ZAPATOS",CALZADO));
    borrador.setColorPrincipal(new Color("0A0A0A"));
    borrador.setCategoria(CALZADO);
    return borrador.instanciarPrenda();
  }
  
}

 Decisiones: 
 
- No hay un control de prendas y criterio del guardarropa porque es algo personalizable por el usuario, es decir, un usuario podria elegir una camisa vieja, un shoggin y medias de salir y clasificarlas como "ROPA_DE_PIJAMA", por lo que al ser tan subjetivo prefiero no poner controles sobre esas categorias.

- Para que los usuarios compartan un guardaRopasCompartido, varios usuarios referenciaran al mismo objeto guardaRopa, al momento de que un usuario instancie un guardaRopaCompartido se le avisara a todos los usuarios con los que comparte que deberan agregarlo a su lista de guardaRopas (se podria aÃ±adir un control para aceptar o denegar la solicitud)

- Existe una doble referencia entre una modificacion (que conoce a su guardaRopa) y un guardaRopa (que tiene una lista de modificaciones) esto se justifica ya que se usan para poder rollbackear modificaciones sobre un guardaRopa
